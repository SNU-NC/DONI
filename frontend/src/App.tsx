import React, { useState, useRef, useCallback, memo, useEffect } from 'react';
import HTMLFlipBook from 'react-pageflip';
import './App.css';
import { createTypeStream } from 'hangul-typing-animation';

interface Message {
    content: string;
    isUser: boolean;
    timestamp: string;
}

interface Reference {
    tool?: string;
    referenced_content?: string;
    filename?: string;
    page_number?: number;
    link?: string;
    title?: string;
    broker?: string;
    target_price?: string;
    investment_opinion?: string;
    analysis_result?: string;
    type?: string;
    content?: string;
}

interface PlanStep {
    tool: string;
    description: string;
    status: 'pending' | 'running' | 'completed';
}

interface TaskProgress {
    type: string;
    status: string;
    task_id?: string;
    task_name?: string;
    result?: any;
    debug_info?: any;
    timestamp: string;
    task_count?: number;
    results?: any[];
    tool_type?: string;
}

interface TaskEvent {
    type: string;
    data: TaskProgress;
}

const typeIcons = {
    'analyst_report': 'üìä',
    'financial_report': 'üìë',
    'market_analysis': 'üìà',
    'reference': 'üìö',
    'web_search': 'üåê',
    'other': 'üìÑ'
};

const getDisplayType = (ref: Reference) => {
    if (ref.tool?.includes('analyst')) return 'analyst_report';
    if (ref.tool?.includes('financial')) return 'financial_report';
    if (ref.tool?.includes('market')) return 'market_analysis';
    if (ref.tool?.includes('web')) return 'web_search';
    return 'other';
};

const getDisplayTitle = (ref: Reference) => {
    if (ref.title) return ref.title;
    if (ref.filename) return ref.filename;
    return ref.tool || 'Ï∞∏Í≥†ÏûêÎ£å';
};

const getDisplayContent = (ref: Reference) => {
    let content = '';
    let details: string[] = [];

    if (ref.referenced_content) {
        content = ref.referenced_content;
    } else if (ref.analysis_result) {
        content = ref.analysis_result;
    } else if (ref.content) {
        content = ref.content;
    }
    
    if (ref.broker) {
        details.push(`${ref.broker}`);
    }
    if (ref.target_price) {
        details.push(`Î™©ÌëúÍ∞Ä: ${ref.target_price}`);
    }
    if (ref.investment_opinion) {
        details.push(`Ìà¨ÏûêÏùòÍ≤¨: ${ref.investment_opinion}`);
    }
    
    return {
        mainContent: content,
        details: details.join(' | ')
    };
};

declare global {
    interface Window {
        TypeHangul: any;
        Hangul: any;
        Typed: any;
    }
}

const ThinkingMessage = memo(() => {
    const [thinkingMessage, setThinkingMessage] = useState("");

    const thinkingMessages = [
        "Ìïú Î≤àÏóê Ìïú Í∞ÄÏßÄ ÏßàÎ¨∏ÏùÑ ÌïòÎ©¥ Îçî Ï¢ãÏùÄ ÎãµÎ≥ÄÏùÑ ÎìúÎ¶¥ Ïàò ÏûàÏñ¥Ïöî!",
        "Ï†ïÌôïÌïú Í∏∞ÏóÖÎ™ÖÏùÑ ÎÑ£Ïñ¥ ÏßàÎ¨∏Ìï¥Ï£ºÏãúÎ©¥ Îçî Ï¢ãÏùÄ ÎãµÎ≥ÄÏùÑ ÎìúÎ¶¥ Ïàò ÏûàÏñ¥Ïöî!",
        "Ïû¨Î¨¥Î≥¥Í≥†ÏÑú, Ïï†ÎÑêÎ¶¨Ïä§Ìä∏ Î≥¥Í≥†ÏÑú, Ïõπ Ï§ë Ïñ¥Îñ§ Ï†ïÎ≥¥Î•º Ï∞∏Í≥†Ìï†ÏßÄ ÏßÄÏ†ïÌï¥Ï£ºÏãúÎ©¥ Í±∞Í∏∞ÏÑú Ï∞æÏïÑÏò¨Í≤åÏöî!",
        "ÏïåÍ≥† Í≥ÑÏÖ®ÎÇòÏöî? ÌùêÎ¶∞ ÎÇ†ÏóêÎäî Ï£ºÏãù ÏàòÏùµÎ•†Ïù¥ ÌïòÎùΩÌïúÎã§Îäî Ïó∞Íµ¨Í∞Ä ÏûàÏäµÎãàÎã§!",
        "Ï£ºÏãù ÏãúÏû•ÏùÄ Ïù∏ÎÇ¥Ïã¨Ïù¥ ÏóÜÎäî ÏûêÎ°úÎ∂ÄÌÑ∞ Ïù∏ÎÇ¥Ïã¨Ïù¥ ÎßéÏùÄ ÏûêÏóêÍ≤åÎ°ú ÎèàÏù¥ ÎÑòÏñ¥Í∞ÄÎèÑÎ°ù ÏÑ§Í≥ÑÎêòÏñ¥ ÏûàÎã§  - ÏõåÎ†å Î≤ÑÌïè",
        "Ï†ÄÏ∂ïÍ≥º Ìà¨ÏûêÏùò Ï≤´ Î≤àÏß∏ Î™©ÌëúÎäî Ïù∏ÌîåÎ†àÏù¥ÏÖòÏùÑ Ïù¥Í∏∞Îäî Í≤ÉÏù¥Îã§. Ïó¨Îü¨Î∂ÑÏùò ÎèàÏùÄ Í±∞Íæ∏Î°ú ÎèåÏïÑÍ∞ÄÎäî Ï≥áÎ∞îÌÄ¥Ïóê ÏûàÎã§.   - ÌîºÌÑ∞ Î¶∞Ïπò",
        "Í∞úÎ•º Îç∞Î¶¨Í≥† ÏÇ∞Ï±ÖÏùÑ ÎÇòÍ∞à Îïå Í∞úÍ∞Ä Ï£ºÏù∏Î≥¥Îã§ ÏïûÏÑúÍ∞à ÏàòÎäî ÏûàÏñ¥ÎèÑ Ï£ºÏù∏ÏùÑ Îñ†ÎÇ† ÏàòÎäî ÏóÜÎã§. Ïó¨Í∏∞ÏÑú Í∞úÎäî Ï£ºÏãù Í∞ÄÍ≤©Ïù¥Í≥†, Ï£ºÏù∏ÏùÄ Í∏∞ÏóÖÍ∞ÄÏπòÏù¥Îã§.  - ÏïôÎìúÎ†à ÏΩîÏä§ÌÜ®ÎùºÎãà",
        "ÌòÑÎ™ÖÌïú Ìà¨ÏûêÏûêÎäî ÎπÑÍ¥ÄÏ£ºÏùòÏûêÏóêÍ≤å Ï£ºÏãùÏùÑ ÏÇ¨ÏÑú ÎÇôÍ¥ÄÏ£ºÏùòÏûêÏóêÍ≤å ÌåêÎã§. - Î≤§ÏûêÎØº Í∑∏Î†àÏù¥ÏóÑ",
        "Ï†ÄÌù¨Í∞Ä Ï†úÍ≥µÌïòÎäî Ï∂úÏ≤òÎ•º ÎãµÎ≥ÄÍ≥º Ìï®Íªò Î≥¥ÏãúÎ©¥ Îçî Ï†ïÌôïÌïú Ï†ïÎ≥¥Î•º ÏñªÏúºÏã§ Ïàò ÏûàÏäµÎãàÎã§.",
        "ÏïåÍ≥† Í≥ÑÏÖ®ÎÇòÏöî? DONIÎ•º ÌÖåÏä§Ìä∏ÌïòÍ∏∞ ÏúÑÌï¥ ÎßåÎì† 100Ïó¨ Í∞úÏùò ÏßàÎ¨∏-Ï†ïÎãµ ÏåçÏùÄ Ï†ÑÎ∂Ä ÏÇ¨ÎûåÏù¥ ÏßÅÏ†ë ÎßåÎì§ÏóàÏäµÎãàÎã§.",
        "ÏïåÍ≥† Í≥ÑÏÖ®ÎÇòÏöî? Ïñ¥Îñ§ Í∏∞ÏóÖÏùÄ Îß§Ï∂úÏù¥ÎûÄ ÌëúÌòÑ ÎåÄÏã† ÏòÅÏóÖÏàòÏùµÏù¥ÎûÄ ÌëúÌòÑÏùÑ ÏÇ¨Ïö©Ìï©ÎãàÎã§.",
        "DONIÎäî KOSPIÍ∏∞ÏóÖÏóê ÎåÄÌïú Í≤ÄÏÉâÏóê ÏµúÏ†ÅÌôîÎêòÏñ¥ ÏûàÏäµÎãàÎã§.",
        "ÏïåÍ≥† Í≥ÑÏÖ®ÎÇòÏöî? ÎÑ§Ïù¥Î≤Ñ Ïù∏Í∑ºÏóêÎäî 'ÎèôÎ¥âÍ¥Ä'Ïù¥ÎùºÎäî ÏóÑÏ≤≠ÎÇú ÎßõÏßëÏù¥ ÏûàÏäµÎãàÎã§. ÌåÄÏõê Ï§ë ÎàÑÍµ∞Í∞ÄÎäî ÌîÑÎ°úÏ†ùÌä∏ Í∏∞Í∞Ñ Ï§ë 12Ìöå Î∞©Î¨∏ÌñàÏäµÎãàÎã§.",
        "SNU 9Í∏∞ ÌååÏù¥ÌåÖ ‚ô• ‚ô•",
        "ÏïåÍ≥† Í≥ÑÏÖ®ÎÇòÏöî? Í∏∞ÏóÖÏù¥ ÏûêÏÇ¨Ï£ºÎ•º Îß§ÏûÖÌïòÎ©¥ Ï£ºÍ∞ÄÍ∞Ä ÏÉÅÏäπÌïòÎäî Í≤ΩÌñ•Ïù¥ ÏûàÏßÄÎßå, Ïû•Í∏∞Ï†ÅÏúºÎ°úÎäî Î∞òÎìúÏãú Í∏çÏ†ïÏ†ÅÏù∏ ÏòÅÌñ•ÏùÑ ÎØ∏ÏπòÏßÄÎäî ÏïäÏäµÎãàÎã§.",
        "ÏïåÍ≥† Í≥ÑÏÖ®ÎÇòÏöî? ÎØ∏Íµ≠ÏóêÏÑúÎäî IPO Ï≤´ÎÇ† Ï£ºÍ∞ÄÍ∞Ä ÌÅ¨Í≤å ÏÉÅÏäπÌïòÎäî Í≤ÉÏùÑ 'IPO Ìåù(Pop)'Ïù¥ÎùºÍ≥† Î∂ÄÎ¶ÖÎãàÎã§.",
        "ÏïåÍ≥† Í≥ÑÏÖ®ÎÇòÏöî? ÏõåÎü∞ Î≤ÑÌïèÏùÄ Ìà¨Ïûê Í≤∞Ï†ïÏùÑ ÎÇ¥Î¶¥ Îïå 'ÎÇ¥Í∞Ä Ïù¥ Í∏∞ÏóÖÏùò Ï†ÑÎ∂ÄÎ•º ÏÇ∞Îã§Î©¥?'Ïù¥ÎùºÎäî ÏßàÎ¨∏ÏùÑ Ìï≠ÏÉÅ Î®ºÏ†Ä ÌïúÎã§Í≥† Ìï©ÎãàÎã§.",
        "ÏïåÍ≥† Í≥ÑÏÖ®ÎÇòÏöî? Îã¨Îü¨ Í∞ïÏÑ∏Îäî Ï¢ÖÏ¢Ö Ìï¥Ïô∏ Îß§Ï∂ú ÎπÑÏ§ëÏù¥ ÎÜíÏùÄ Í∏∞ÏóÖÏóê Î∂ÄÏ†ïÏ†ÅÏù∏ ÏòÅÌñ•ÏùÑ ÎØ∏Ïπ† Ïàò ÏûàÏäµÎãàÎã§.",
        "ÏïåÍ≥† Í≥ÑÏÖ®ÎÇòÏöî? Ï£ºÏãù Î¶¨Îî©Î∞©ÏùÄ Ìà¨ÏûêÏûêÎ•º ÏÜçÏù¥Îäî ÏÇ¨Í∏∞ ÏàòÎã®ÏúºÎ°ú ÏïÖÏö©ÎêòÎäî Í≤ΩÏö∞Í∞Ä ÎßéÏäµÎãàÎã§."
    ];

    useEffect(() => {
        const interval = setInterval(() => {
            const randomIndex = Math.floor(Math.random() * thinkingMessages.length);
            setThinkingMessage(thinkingMessages[randomIndex]);
        }, 2700);
        
        const initialIndex = Math.floor(Math.random() * thinkingMessages.length);
        setThinkingMessage(thinkingMessages[initialIndex]);
        
        return () => clearInterval(interval);
    }, []);

    return (
        <div className="message-container">
            <div className="avatar">
                <img src="/component/imgs/robot_avatar.png" alt="AI Ï±óÎ¥á" />
            </div>
            <div className="message bot-message thinking">
                <div className="thinking-header">
                    ÏÉùÍ∞Å Ï§ë
                    <div className="loading-dots">
                        <span></span>
                        <span></span>
                        <span></span>
                    </div>
                </div>
                <div className="thinking-tip">
                    Tip: {thinkingMessage}
                </div>
            </div>
        </div>
    );
});

const MessageItem = memo(({ msg, idx, isNew }: { msg: Message; idx: number; isNew?: boolean }) => {
    const messageRef = useRef<HTMLDivElement>(null);
    const typeStreamRef = useRef<any>(null);

    useEffect(() => {
        if (!msg.isUser && isNew && messageRef.current) {
            const typeStream = createTypeStream({
                perChar: 20,    // ÏùºÎ∞ò Î¨∏Ïûê ÌÉÄÏù¥Ìïë ÏÜçÎèÑ
                perHangul: 0,  // ÌïúÍ∏Ä ÌÉÄÏù¥Ìïë ÏÜçÎèÑ
                perSpace: 0,    // Í≥µÎ∞± ÌÉÄÏù¥Ìïë ÏÜçÎèÑ
                perLine: 0,     // Ï§ÑÎ∞îÍøà ÌÉÄÏù¥Ìïë ÏÜçÎèÑ
                perDot: 0     // ÎßàÏπ®Ìëú ÌÉÄÏù¥Ìïë ÏÜçÎèÑ
            });

            const timer = setTimeout(() => {
                if (messageRef.current) {
                    typeStreamRef.current = typeStream(msg.content, (typing) => {
                        if (messageRef.current) {
                            messageRef.current.textContent = typing;
                        }
                    });
                }
            }, 500);

            return () => {
                clearTimeout(timer);
            };
        } else if (messageRef.current) {
            messageRef.current.textContent = msg.content;
        }
    }, [msg.isUser, isNew, msg.content]);

    return (
        <div className={`message-container ${msg.isUser ? 'user' : ''} ${isNew ? 'new-message' : ''}`}>
            <div className={`avatar ${msg.isUser ? 'user' : ''}`}>
                {msg.isUser ? 'üë§' : <img src="/component/imgs/robot_avatar.png" alt="AI Ï±óÎ¥á" />}
            </div>
            <div 
                ref={!msg.isUser ? messageRef : null}
                className={`message ${msg.isUser ? 'user-message' : 'bot-message'}`}
            >
                {msg.isUser ? msg.content : ''}
            </div>
            <div className="timestamp">{msg.timestamp}</div>
        </div>
    );
});

const ChatMessages = memo(({ messages, isThinking }: { messages: Message[]; isThinking: boolean }) => {
    const messagesEndRef = useRef<HTMLDivElement>(null);
    const chatContainerRef = useRef<HTMLDivElement>(null);
    const [isInitialLoad, setIsInitialLoad] = useState(true);
    const [shouldAutoScroll, setShouldAutoScroll] = useState(true);
    const lastMessageRef = useRef<HTMLDivElement>(null);
    
    // Ïä§ÌÅ¨Î°§ ÏúÑÏπò Í∞êÏßÄ
    // useCallback ÏÇ¨Ïö© Ïù¥Ïú†: Ìï®Ïàò Ïû¨ÏÉùÏÑ± Î∞©ÏßÄ Ïù∏ÏûêÎ°ú Ï†ÑÎã¨Ìïú Ìï®Ïàò ÏûêÏ≤¥Î•º Î©îÎ™®ÎùºÏù¥Ï†úÏù¥ÏÖò 
    const handleScroll = useCallback(() => {
        if (!chatContainerRef.current) return;
        
        const { scrollTop, scrollHeight, clientHeight } = chatContainerRef.current;
        const isNearBottom = scrollHeight - (scrollTop + clientHeight) < 100;
        setShouldAutoScroll(isNearBottom);
    }, []);

    useEffect(() => {
        const container = chatContainerRef.current;
        if (container) {
            container.addEventListener('scroll', handleScroll);
            return () => container.removeEventListener('scroll', handleScroll);
        }
    }, [handleScroll]);

    // ÏÉà Î©îÏãúÏßÄÍ∞Ä Ï∂îÍ∞ÄÎê† Îïå Ïä§ÌÅ¨Î°§
    useEffect(() => {
        if (isInitialLoad) {
            if (chatContainerRef.current) {
                chatContainerRef.current.scrollTop = 0;
            }
            setIsInitialLoad(false);
        } else if (shouldAutoScroll && messagesEndRef.current) {
            messagesEndRef.current.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }
    }, [messages, isInitialLoad, shouldAutoScroll]);

    return (
        <div className="chat-messages" ref={chatContainerRef}>
            <div className="messages-wrapper">
                {messages.map((msg, idx) => (
                    <div 
                        key={msg.timestamp + '-' + idx}
                        ref={idx === messages.length - 1 ? lastMessageRef : null}
                    >
                        <MessageItem 
                            msg={msg} 
                            idx={idx}
                            isNew={idx === messages.length - 1 && !isInitialLoad}
                        />
                    </div>
                ))}
                {isThinking && <ThinkingMessage />}
                <div ref={messagesEndRef} style={{ height: '20px' }} />
            </div>
        </div>
    );
});

const ChatPage = memo(React.forwardRef<HTMLDivElement, { messages: Message[]; isThinking: boolean }>((props, ref) => {
    return (
        <div className="page chat-page" ref={ref}>
            <div className="page-header">
                <h2>üí¨ ÎåÄÌôî</h2>
            </div>
            <ChatMessages messages={props.messages} isThinking={props.isThinking} />
        </div>
    );
}));

const ReferencePage = React.forwardRef<HTMLDivElement, { references: Reference[] }>((props, ref) => {
    return (
        <div className="page reference-page" ref={ref}>
            <div className="page-header">
                <h2>üìö Ï∞∏Í≥† ÏûêÎ£å</h2>
            </div>
            <div className="references-container">
                {props.references.map((ref, idx) => {
                    const displayType = getDisplayType(ref);
                    const displayTitle = getDisplayTitle(ref);
                    const {mainContent, details} = getDisplayContent(ref);
                    
                    return (
                        <div key={idx} className="reference-item">
                            <div className="reference-title">
                                {typeIcons[displayType as keyof typeof typeIcons]} {displayTitle}
                                {ref.page_number && ` (p.${ref.page_number})`}
                            </div>
                            {details && <div className="reference-details">{details}</div>}
                            <div className="reference-content">{mainContent}</div>
                            {ref.link && (
                                <a href={ref.link} target="_blank" rel="noopener noreferrer" className="reference-link">
                                    ÏõêÎ¨∏ Î≥¥Í∏∞
                                </a>
                            )}
                        </div>
                    );
                })}
            </div>
        </div>
    );
});

const PlanningPage = React.forwardRef<HTMLDivElement, { plans: PlanStep[] }>((props, ref) => {
    return (
        <div className="page planning-page" ref={ref}>
            <div className="page-header">
                <h2>ü§î ÏÉùÍ∞ÅÏùò Í≥ºÏ†ï</h2>
            </div>
            <div className="planning-container">
                {props.plans.map((plan, idx) => (
                    <div key={idx} className={`plan-step ${plan.status}`}>
                        <div className="plan-number">{idx + 1}</div>
                        <div className="plan-content">
                            <div className="plan-tool">{plan.tool}</div>
                            <div className="plan-description">{plan.description}</div>
                        </div>
                        <div className="plan-status">
                            {plan.status === 'pending' && '‚è≥'}
                            {plan.status === 'running' && 'üîÑ'}
                            {plan.status === 'completed' && '‚úÖ'}
                        </div>
                    </div>
                ))}
            </div>
        </div>
    );
});

const InputComponent = memo(({ onSend, isThinking }: { onSend: (value: string) => void, isThinking: boolean }) => {
    const [inputValue, setInputValue] = useState('');

    const handleSend = useCallback(() => {
        if (!inputValue.trim()) return;
        onSend(inputValue);
        setInputValue('');
    }, [inputValue, onSend]);

    return (
        <div className="input-container">
            <input
                type="text"
                value={inputValue}
                onChange={(e) => setInputValue(e.target.value)}
                onKeyPress={(e) => e.key === 'Enter' && handleSend()}
                placeholder="ÏßàÎ¨∏ÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî..."
                disabled={isThinking}
            />
            <button onClick={handleSend} disabled={isThinking}>
                {isThinking ? 'Ï†ÑÏÜ°' : 'Ï†ÑÏÜ°'}
            </button>
        </div>
    );
});

// ÎèÑÍµ¨ ÌÉÄÏûÖÎ≥Ñ ÌëúÏãú Ïù¥Î¶Ñ Îß§Ìïë
const toolTypeIcons = {
    'combined_financial_report_search': 'üìë Ïû¨Î¨¥Ï†úÌëú Í≤ÄÏÉâ',
    'web_search': 'üåê Ïõπ Í≤ÄÏÉâ',
    'math': 'üî¢ ÏàòÏãù Í≥ÑÏÇ∞',
    'report_analysis': 'üìä Î¶¨Ìè¨Ìä∏ Î∂ÑÏÑù',
    'stock_analysis': 'üìà Ï£ºÍ∞Ä Î∂ÑÏÑù',
    'combined_analysis': 'üîç Ï¢ÖÌï© Î∂ÑÏÑù',
    'sector_analysis': 'üè¢ ÏÑπÌÑ∞ Î∂ÑÏÑù',
    'market_data': 'üìä ÏãúÏû• Îç∞Ïù¥ÌÑ∞',
    'join': 'üîó Îç∞Ïù¥ÌÑ∞ Í≤∞Ìï©',
    'Í∏∞ÌÉÄ': 'üîß Í∏∞ÌÉÄ'
};

const TaskProgressDisplay = memo(({ taskEvents }: { taskEvents: TaskProgress[] }) => {
    return (
        <div className="task-progress-container">
            <div className="task-events-list">
                {taskEvents.map((event, index) => (
                    <div key={`${event.timestamp}-${index}`} className={`task-event ${event.status}`}>
                        <div className="task-event-header">
                            <span className="task-type">
                                {toolTypeIcons[event.tool_type as keyof typeof toolTypeIcons] || 
                                 toolTypeIcons[event.task_name as keyof typeof toolTypeIcons]}
                            </span>
                            <span className={`task-status ${event.status}`}>
                                {event.status === 'running' && 'Ïã§Ìñâ Ï§ë'}
                                {event.status === 'completed' && 'ÏôÑÎ£å'}
                                {event.status === 'error' && 'Ïò§Î•ò'}
                                {event.status === 'pending' && 'ÎåÄÍ∏∞ Ï§ë'}
                            </span>
                        </div>
                        <div className="task-timestamp">
                            {new Date(event.timestamp).toLocaleTimeString()}
                        </div>
                    </div>
                ))}
            </div>
        </div>
    );
});

function App() {
    const [messages, setMessages] = useState<Message[]>([{
        content: "ÏïàÎÖïÌïòÏÑ∏Ïöî! Í∂ÅÍ∏àÌïú Ï†ïÎ≥¥Î•º ÏûêÏú†Î°≠Í≤å ÏßàÎ¨∏Ìï¥Ï£ºÏÑ∏Ïöî.",
        isUser: false,
        timestamp: new Date().toLocaleTimeString()
    }]);
    const [isThinking, setIsThinking] = useState(false);
    const [references, setReferences] = useState<Reference[]>([]);
    const [planSteps, setPlanSteps] = useState<PlanStep[]>([]);
    const [currentQuery, setCurrentQuery] = useState<string>("");
    const [taskProgress, setTaskProgress] = useState<TaskProgress[]>([]);
    const [isConnected, setIsConnected] = useState(false);
    const wsRef = useRef<WebSocket | null>(null);
    const [debugMessages, setDebugMessages] = useState<string[]>([]);
    const [isFading, setIsFading] = useState(false);
    const taskQueueRef = useRef<TaskProgress[]>([]);
    const [taskEvents, setTaskEvents] = useState<TaskProgress[]>([]);
    const [isDebugVisible, setIsDebugVisible] = useState(false);

    // ÌÉúÏä§ÌÅ¨ ÌÅêÏóê ÏÉàÎ°úÏö¥ ÌÉúÏä§ÌÅ¨ Ï∂îÍ∞Ä
    const addToTaskQueue = useCallback((task: TaskProgress) => {
        // task_idÍ∞Ä ÏûàÎäî Í≤ΩÏö∞ÏóêÎßå Ï∂îÍ∞Ä
        if (task.task_id || task.type === 'execution' || task.type === 'execution_summary') {
            taskQueueRef.current.push({
                ...task,
                tool_type: task.tool_type || task.task_name || 'Í∏∞ÌÉÄ',
                timestamp: task.timestamp || new Date().toISOString()
            });
        }
    }, []);

    // Ï£ºÍ∏∞Ï†ÅÏúºÎ°ú ÌÉúÏä§ÌÅ¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ (100ms Í∞ÑÍ≤©)
    useEffect(() => {
        const updateInterval = setInterval(() => {
            if (taskQueueRef.current.length > 0) {
                setTaskProgress(prev => {
                    const newTasks = [...prev];
                    
                    taskQueueRef.current.forEach(task => {
                        // task_idÍ∞Ä ÏûàÍ±∞ÎÇò execution ÌÉÄÏûÖÏù∏ Í≤ΩÏö∞Îßå Ï≤òÎ¶¨
                        if (task.task_id || task.type === 'execution') {
                            const existingIndex = newTasks.findIndex(t => t.task_id === task.task_id);
                            if (existingIndex !== -1) {
                                newTasks[existingIndex] = { 
                                    ...newTasks[existingIndex], 
                                    ...task,
                                    status: task.status || newTasks[existingIndex].status
                                };
                            } else {
                                newTasks.push(task);
                            }
                        }
                    });
                    
                    // ÏÉÅÌÉúÎ≥ÑÎ°ú Ï†ïÎ†¨
                    const sortedTasks = newTasks.sort((a, b) => {
                        if (a.task_id && b.task_id) {
                            return parseInt(a.task_id) - parseInt(b.task_id);
                        }
                        return new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime();
                    });
                    
                    taskQueueRef.current = []; // ÌÅê Ï¥àÍ∏∞Ìôî
                    return sortedTasks;
                });
            }
        }, 100);

        return () => clearInterval(updateInterval);
    }, []);

    const clearPreviousChat = useCallback(() => {
        setIsFading(true);
        // Ï¶âÏãú Ï¥àÍ∏∞Ìôî
        setReferences([]);
        setPlanSteps([]);
        setTaskProgress([]);
        setDebugMessages([]);
        taskQueueRef.current = []; // ÌÉúÏä§ÌÅ¨ ÌÅêÎèÑ Ï¥àÍ∏∞Ìôî
        
        // ÌéòÏù¥ÎìúÏïÑÏõÉ Ìö®Í≥º ÌõÑ ÌéòÏù¥ÎìúÏù∏
        setTimeout(() => {
            setIsFading(false);
        }, 500);
    }, []);

    const handleSubmit = async (query: string) => {
        if (!query.trim()) return;
        
        // ÏÉàÎ°úÏö¥ ÏßàÎ¨∏Ïù¥ Îì§Ïñ¥Ïò§Î©¥ Î™®Îì† Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî
        clearPreviousChat();
        setCurrentQuery(query);
        // ÏûëÏóÖ ÏßÑÌñâ ÏÉÅÌô©Í≥º ÎîîÎ≤ÑÍ∑∏ ÏΩòÏÜî Ï¥àÍ∏∞Ìôî
        setTaskEvents([]);
        setDebugMessages([]);
        setTaskProgress([]);
        taskQueueRef.current = [];

        const userMessage: Message = {
            content: query,
            isUser: true,
            timestamp: new Date().toLocaleTimeString()
        };

        setMessages(prev => [...prev, userMessage]);
        setIsThinking(true);

        try {
            const response = await fetch('http://localhost:8000/api/search', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ query })
            });

            const data = await response.json();

            if (data.error) {
                const errorMessage: Message = {
                    content: data.message || "Ï£ÑÏÜ°Ìï©ÎãàÎã§. Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
                    isUser: false,
                    timestamp: new Date().toLocaleTimeString()
                };
                setMessages(prev => [...prev, errorMessage]);
            } else {
                const botMessage: Message = {
                    content: data.answer,
                    isUser: false,
                    timestamp: new Date().toLocaleTimeString()
                };
                setMessages(prev => [...prev, botMessage]);
                
                // Ï∞∏Í≥† ÏûêÎ£åÍ∞Ä ÏûàÎã§Î©¥ ÏóÖÎç∞Ïù¥Ìä∏
                if (data.docs && Array.isArray(data.docs)) {
                    setReferences(data.docs);
                }
            }
        } catch (error) {
            const errorMessage: Message = {
                content: "ÏÑúÎ≤ÑÏôÄÏùò ÌÜµÏã† Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.",
                isUser: false,
                timestamp: new Date().toLocaleTimeString()
            };
            setMessages(prev => [...prev, errorMessage]);
        } finally {
            setIsThinking(false);
        }
    };

    // ÎîîÎ≤ÑÍ∑∏ Î©îÏãúÏßÄ Ï∂îÍ∞Ä Ìï®Ïàò
    const addDebugMessage = (message: string) => {
        setDebugMessages(prev => [...prev, `${new Date().toISOString()} - ${message}`]);
        console.log(message);
    };

    useEffect(() => {
        const connectWebSocket = () => {
            // Í∏∞Ï°¥ ÏõπÏÜåÏºìÏù¥ ÏûàÎã§Î©¥ Îã´Í∏∞
            if (wsRef.current) {
                wsRef.current.close();
            }

            const ws = new WebSocket('ws://localhost:8000/ws/task-progress');
            wsRef.current = ws;

            ws.onopen = () => {
                setIsConnected(true);
                addDebugMessage('WebSocket Ïó∞Í≤∞Îê®');
            };

            ws.onmessage = (event) => {
                const data: TaskEvent = JSON.parse(event.data);
                addDebugMessage(`ÏÉàÎ°úÏö¥ ÌÉúÏä§ÌÅ¨ Ïù¥Î≤§Ìä∏ ÏàòÏã†: ${JSON.stringify(data)}`);
                
                if (data.type === 'task_progress') {
                    const taskData = data.data;
                    
                    // Í∏∞ÌÉÄ ÌÉÄÏûÖÏù¥Î©¥ Î¨¥Ïãú
                    if (taskData.tool_type === 'Í∏∞ÌÉÄ' || taskData.task_name === 'Í∏∞ÌÉÄ') {
                        return;
                    }
                    
                    // taskEvents ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
                    setTaskEvents(prev => {
                        // ÎèôÏùºÌïú task_idÏôÄ tool_typeÏùÑ Í∞ÄÏßÑ Ïù¥Î≤§Ìä∏ Ï∞æÍ∏∞
                        const existingEventIndex = prev.findIndex(
                            event => event.task_id === taskData.task_id && 
                                    event.tool_type === taskData.tool_type
                        );

                        // Ïù¥ÎØ∏ Ï°¥Ïû¨ÌïòÎäî Ïù¥Î≤§Ìä∏ÎùºÎ©¥
                        if (existingEventIndex !== -1) {
                            // ÏÉÅÌÉúÍ∞Ä Í∞ôÏúºÎ©¥ Î¨¥Ïãú
                            if (prev[existingEventIndex].status === taskData.status) {
                                return prev;
                            }
                            
                            // ÏÉÅÌÉúÍ∞Ä Îã§Î•¥Î©¥ ÏóÖÎç∞Ïù¥Ìä∏
                            const newEvents = [...prev];
                            newEvents[existingEventIndex] = {
                                ...newEvents[existingEventIndex],
                                status: taskData.status,
                                timestamp: taskData.timestamp
                            };
                            return newEvents;
                        }
                        
                        // ÏÉàÎ°úÏö¥ Ïù¥Î≤§Ìä∏ÎùºÎ©¥ Ï∂îÍ∞Ä
                        return [...prev, taskData];
                    });
                }
            };

            ws.onerror = (error) => {
                addDebugMessage(`WebSocket Ïò§Î•ò: ${error}`);
                setIsConnected(false);
            };

            ws.onclose = () => {
                setIsConnected(false);
                addDebugMessage('WebSocket Ïó∞Í≤∞ Ï¢ÖÎ£å');
                // Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ
                setTimeout(connectWebSocket, 3000);
            };
        };

        connectWebSocket();

        // Ïª¥Ìè¨ÎÑåÌä∏ Ïñ∏ÎßàÏö¥Ìä∏ Ïãú ÏõπÏÜåÏºì Ïó∞Í≤∞ Ï¢ÖÎ£å
        return () => {
            if (wsRef.current) {
                wsRef.current.close();
                wsRef.current = null;
            }
        };
    }, [currentQuery]); // currentQueryÍ∞Ä Î≥ÄÍ≤ΩÎê† ÎïåÎßàÎã§ ÏõπÏÜåÏºì Ïû¨Ïó∞Í≤∞

    return (
        <div className="app-container">
            <div className="sections-container">
                <section className="task-progress-section">
                    <div className="section-header">
                        <h2>üîÑ ÏßÑÌñâ ÏÉÅÌô©</h2>
                    </div>
                    <TaskProgressDisplay taskEvents={taskEvents} />
                </section>

                <section className="chat-section">
                    <div className="section-header">
                        <h2>üí¨ ÎåÄÌôî</h2>
                    </div>
                    <ChatMessages messages={messages} isThinking={isThinking} />
                </section>

                <section className="reference-section">
                    <div className="section-header">
                        <div className="header-with-button">
                            <h2>üìö Ï∞∏Í≥† ÏûêÎ£å</h2>
                            <button 
                                className="debug-toggle-button"
                                onClick={() => setIsDebugVisible(!isDebugVisible)}
                            >
                                {isDebugVisible ? 'üîΩ ÎîîÎ≤ÑÍ∑∏ Ïà®Í∏∞Í∏∞' : 'üîº ÎîîÎ≤ÑÍ∑∏ Î≥¥Í∏∞'}
                            </button>
                        </div>
                    </div>
                    <div className="reference-content-wrapper">
                        <div className={`references-container ${isFading || isThinking ? 'fade-out' : 'fade-in'}`}>
                            {references.map((ref, idx) => (
                                <div key={idx} className="reference-item">
                                    <div className="reference-title">
                                        {typeIcons[getDisplayType(ref) as keyof typeof typeIcons]} {getDisplayTitle(ref)}
                                        {ref.page_number && ` (p.${ref.page_number})`}
                                    </div>
                                    {ref.broker && <div className="reference-details">{ref.broker}</div>}
                                    <div className="reference-content">{ref.referenced_content || ref.content}</div>
                                    {ref.link && (
                                        <a href={ref.link} target="_blank" rel="noopener noreferrer" className="reference-link">
                                            ÏõêÎ¨∏ Î≥¥Í∏∞
                                        </a>
                                    )}
                                </div>
                            ))}
                        </div>
                        {isDebugVisible && (
                            <div className="debug-console">
                                <h3>ÎîîÎ≤ÑÍ∑∏ ÏΩòÏÜî</h3>
                                <div className="debug-messages">
                                    {debugMessages.map((message, index) => (
                                        <div key={index} className="debug-message">
                                            {message}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}
                    </div>
                </section>
            </div>
            
            <InputComponent onSend={handleSubmit} isThinking={isThinking} />
        </div>
    );
}

export default App; 